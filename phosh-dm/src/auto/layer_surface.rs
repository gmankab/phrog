// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_};

glib::wrapper! {
    #[doc(alias = "PhoshLayerSurface")]
    pub struct LayerSurface(Object<ffi::PhoshLayerSurface, ffi::PhoshLayerSurfaceClass>);

    match fn {
        type_ => || ffi::phosh_layer_surface_get_type(),
    }
}

impl LayerSurface {
        pub const NONE: Option<&'static LayerSurface> = None;
    
}

mod sealed {
    pub trait Sealed {}
    impl<T: super::IsA<super::LayerSurface>> Sealed for T {}
}

pub trait LayerSurfaceExt: IsA<LayerSurface> + sealed::Sealed + 'static {
    fn anchor(&self) -> u32 {
        ObjectExt::property(self.as_ref(), "anchor")
    }

    fn set_anchor(&self, anchor: u32) {
        ObjectExt::set_property(self.as_ref(),"anchor", anchor)
    }

    #[doc(alias = "configured-height")]
    fn configured_height(&self) -> u32 {
        ObjectExt::property(self.as_ref(), "configured-height")
    }

    #[doc(alias = "configured-width")]
    fn configured_width(&self) -> u32 {
        ObjectExt::property(self.as_ref(), "configured-width")
    }

    #[doc(alias = "exclusive-zone")]
    fn exclusive_zone(&self) -> i32 {
        ObjectExt::property(self.as_ref(), "exclusive-zone")
    }

    #[doc(alias = "exclusive-zone")]
    fn set_exclusive_zone(&self, exclusive_zone: i32) {
        ObjectExt::set_property(self.as_ref(),"exclusive-zone", exclusive_zone)
    }

    fn height(&self) -> u32 {
        ObjectExt::property(self.as_ref(), "height")
    }

    fn set_height(&self, height: u32) {
        ObjectExt::set_property(self.as_ref(),"height", height)
    }

    #[doc(alias = "kbd-interactivity")]
    fn is_kbd_interactivity(&self) -> bool {
        ObjectExt::property(self.as_ref(), "kbd-interactivity")
    }

    #[doc(alias = "kbd-interactivity")]
    fn set_kbd_interactivity(&self, kbd_interactivity: bool) {
        ObjectExt::set_property(self.as_ref(),"kbd-interactivity", kbd_interactivity)
    }

    fn layer(&self) -> u32 {
        ObjectExt::property(self.as_ref(), "layer")
    }

    fn set_layer(&self, layer: u32) {
        ObjectExt::set_property(self.as_ref(),"layer", layer)
    }

    //#[doc(alias = "layer-shell")]
    //fn layer_shell(&self) -> /*Unimplemented*/Basic: Pointer {
    //    ObjectExt::property(self.as_ref(), "layer-shell")
    //}

    //#[doc(alias = "layer-shell")]
    //fn set_layer_shell(&self, layer_shell: /*Unimplemented*/Basic: Pointer) {
    //    ObjectExt::set_property(self.as_ref(),"layer-shell", layer_shell)
    //}

    fn namespace(&self) -> Option<glib::GString> {
        ObjectExt::property(self.as_ref(), "namespace")
    }

    fn set_namespace(&self, namespace: Option<&str>) {
        ObjectExt::set_property(self.as_ref(),"namespace", namespace)
    }

    fn width(&self) -> u32 {
        ObjectExt::property(self.as_ref(), "width")
    }

    fn set_width(&self, width: u32) {
        ObjectExt::set_property(self.as_ref(),"width", width)
    }

    //#[doc(alias = "wl-output")]
    //fn wl_output(&self) -> /*Unimplemented*/Basic: Pointer {
    //    ObjectExt::property(self.as_ref(), "wl-output")
    //}

    //#[doc(alias = "wl-output")]
    //fn set_wl_output(&self, wl_output: /*Unimplemented*/Basic: Pointer) {
    //    ObjectExt::set_property(self.as_ref(),"wl-output", wl_output)
    //}

    #[doc(alias = "configured")]
    fn connect_configured<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn configured_trampoline<P: IsA<LayerSurface>, F: Fn(&P) + 'static>(this: *mut ffi::PhoshLayerSurface, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(LayerSurface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"configured\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(configured_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "anchor")]
    fn connect_anchor_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_anchor_trampoline<P: IsA<LayerSurface>, F: Fn(&P) + 'static>(this: *mut ffi::PhoshLayerSurface, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(LayerSurface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::anchor\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_anchor_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "configured-height")]
    fn connect_configured_height_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_configured_height_trampoline<P: IsA<LayerSurface>, F: Fn(&P) + 'static>(this: *mut ffi::PhoshLayerSurface, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(LayerSurface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::configured-height\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_configured_height_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "configured-width")]
    fn connect_configured_width_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_configured_width_trampoline<P: IsA<LayerSurface>, F: Fn(&P) + 'static>(this: *mut ffi::PhoshLayerSurface, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(LayerSurface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::configured-width\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_configured_width_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "exclusive-zone")]
    fn connect_exclusive_zone_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_exclusive_zone_trampoline<P: IsA<LayerSurface>, F: Fn(&P) + 'static>(this: *mut ffi::PhoshLayerSurface, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(LayerSurface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::exclusive-zone\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_exclusive_zone_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "height")]
    fn connect_height_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_height_trampoline<P: IsA<LayerSurface>, F: Fn(&P) + 'static>(this: *mut ffi::PhoshLayerSurface, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(LayerSurface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::height\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_height_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "kbd-interactivity")]
    fn connect_kbd_interactivity_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_kbd_interactivity_trampoline<P: IsA<LayerSurface>, F: Fn(&P) + 'static>(this: *mut ffi::PhoshLayerSurface, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(LayerSurface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::kbd-interactivity\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_kbd_interactivity_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "layer")]
    fn connect_layer_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_layer_trampoline<P: IsA<LayerSurface>, F: Fn(&P) + 'static>(this: *mut ffi::PhoshLayerSurface, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(LayerSurface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::layer\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_layer_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "layer-shell")]
    fn connect_layer_shell_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_layer_shell_trampoline<P: IsA<LayerSurface>, F: Fn(&P) + 'static>(this: *mut ffi::PhoshLayerSurface, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(LayerSurface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::layer-shell\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_layer_shell_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "namespace")]
    fn connect_namespace_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_namespace_trampoline<P: IsA<LayerSurface>, F: Fn(&P) + 'static>(this: *mut ffi::PhoshLayerSurface, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(LayerSurface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::namespace\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_namespace_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "width")]
    fn connect_width_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_width_trampoline<P: IsA<LayerSurface>, F: Fn(&P) + 'static>(this: *mut ffi::PhoshLayerSurface, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(LayerSurface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::width\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_width_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "wl-output")]
    fn connect_wl_output_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_wl_output_trampoline<P: IsA<LayerSurface>, F: Fn(&P) + 'static>(this: *mut ffi::PhoshLayerSurface, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(LayerSurface::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::wl-output\0".as_ptr() as *const _,
                Some(std::mem::transmute::<_, unsafe extern "C" fn()>(notify_wl_output_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl<O: IsA<LayerSurface>> LayerSurfaceExt for O {}
